[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Claymer Documentation",
    "section": "",
    "text": "1 Fibonacci Sequence Function",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fibonacci Sequence Function</span>"
    ]
  },
  {
    "objectID": "index.html#functionality",
    "href": "index.html#functionality",
    "title": "Claymer Documentation",
    "section": "1.1 Functionality",
    "text": "1.1 Functionality\n\nfib: Takes a non-negative integer n and returns the nth Fibonacci number.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fibonacci Sequence Function</span>"
    ]
  },
  {
    "objectID": "index.html#implementation",
    "href": "index.html#implementation",
    "title": "Claymer Documentation",
    "section": "1.2 Implementation",
    "text": "1.2 Implementation\n\n(defn fib [n]\n  (nth (map first (iterate (fn [[a b]] [b (+' a b)]) [0 1])) n))\n\n\n1.2.1 Examples:\nProduces nth number in the fibonacci sequence:\n\n(deftest fib-test\n  (testing\n      (is (= (sut/fib 0) 0)))\n  (testing\n      (is (= (sut/fib 12) 144)))\n  (testing\n      (is (= (sut/fib 69) 117669030460994))))\n\nPASS: (= 0 0)PASS: (= 144 144)PASS: (= 117669030460994 117669030460994)\nNegitive numbers are out of bounds.\n\n(deftest fib-neg-n-out-of-range-test\n  (is\n   (try (sut/fib -1)\n        (catch Exception e\n          (= (type e) java.lang.IndexOutOfBoundsException)))))\n\nPASS: true",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fibonacci Sequence Function</span>"
    ]
  },
  {
    "objectID": "index.html#properties",
    "href": "index.html#properties",
    "title": "Claymer Documentation",
    "section": "1.3 Properties",
    "text": "1.3 Properties\n\n1.3.1 Parity Invarient\nEvery third Fibonacci number is even. This is because an odd + even = odd so we get the cycle:\n0+1=1 -&gt; 1+1=2 -&gt; 1+2=3 -&gt; ...\nE+O=O -&gt; O+O=E -&gt; O+E=O -&gt; ...\n\n(def parity-invariant\n  (prop/for-all\n   [v gen/pos-int]\n   (let [fib-number (sut/fib v)]\n     (if (zero? (rem v 3))\n       (even? fib-number)\n       (odd? fib-number)))))\n\n\n(tc/quick-check 10000 parity-invariant)\n\n\n{:result true,\n :pass? true,\n :num-tests 10000,\n :time-elapsed-ms 50,\n :seed 1771227759129}",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fibonacci Sequence Function</span>"
    ]
  },
  {
    "objectID": "index.html#performance-comparison",
    "href": "index.html#performance-comparison",
    "title": "Claymer Documentation",
    "section": "1.4 Performance Comparison",
    "text": "1.4 Performance Comparison\nBelow we compare the efficient iterative fib against a naive recursive fib-naive implementation across a range of input sizes. The naive version has exponential time complexity, so its execution time grows dramatically.\n\n\nsource: test/claymer/core_test.clj",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Fibonacci Sequence Function</span>"
    ]
  }
]